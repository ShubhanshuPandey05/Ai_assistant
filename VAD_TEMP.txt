// Add this to track partial data
session.vadOutputBuffer = '';

session.vadProcess.stdout.on('data', (vadData) => {
    console.log("VAD raw data received");
    
    // Add new data to buffer
    session.vadOutputBuffer += vadData.toString();
    
    // Split by lines
    const lines = session.vadOutputBuffer.split('\n');
    
    // Keep the last incomplete line in buffer
    session.vadOutputBuffer = lines.pop() || '';
    
    // Process each complete line
    for (const line of lines) {
        const trimmedLine = line.trim();
        if (!trimmedLine) continue;
        
        try {
            const parsedVAD = JSON.parse(trimmedLine);
            console.log(`Session ${session.id}: VAD Event: ${parsedVAD.event}`);
            
            if (parsedVAD.event === 'speech_start') {
                session.isVadSpeechActive = true;
                console.log(`Session ${session.id}: VAD detected Speech START. Resetting Deepgram buffer.`);
                session.vadDeepgramBuffer = Buffer.alloc(0);
            } else if (parsedVAD.event === 'speech_end') {
                session.isVadSpeechActive = false;
                console.log(`Session ${session.id}: VAD detected Speech END.`);
                
                // Send any remaining buffered audio
                if (session.vadDeepgramBuffer.length > 0 && session.dgSocket?.readyState === 1) {
                    session.dgSocket.send(session.vadDeepgramBuffer);
                    session.vadDeepgramBuffer = Buffer.alloc(0);
                }
                
                // Send finalize message
                if (session.dgSocket?.readyState === 1) {
                    console.log(`Session ${session.id}: Sending Deepgram Finalize message.`);
                    session.dgSocket.send(JSON.stringify({ "type": "Finalize" }));
                }
            }

            // Handle audio chunks
            if (parsedVAD.chunk) {
                console.log(`Session ${session.id}: Got speech chunk (${parsedVAD.chunk.length / 2} chars)`);
                const audioBuffer = Buffer.from(parsedVAD.chunk, 'hex');
                session.vadDeepgramBuffer = Buffer.concat([session.vadDeepgramBuffer, audioBuffer]);
                
                // Send chunks to Deepgram if speech is active
                if (session.isVadSpeechActive && session.dgSocket?.readyState === 1) {
                    while (session.vadDeepgramBuffer.length >= CONFIG.DEEPGRAM_STREAM_CHUNK_SIZE) {
                        const chunkToSend = session.vadDeepgramBuffer.slice(0, CONFIG.DEEPGRAM_STREAM_CHUNK_SIZE);
                        session.dgSocket.send(chunkToSend);
                        session.vadDeepgramBuffer = session.vadDeepgramBuffer.slice(CONFIG.DEEPGRAM_STREAM_CHUNK_SIZE);
                        session.audioStartTime = Date.now();
                    }
                }
            }
        } catch (err) {
            console.log(`Session ${session.id}: Failed to parse VAD line: "${trimmedLine}"`);
            console.error(`Session ${session.id}: VAD output parse error:`, err.message);
        }
    }
});

session.vadProcess.stderr.on('data', (data) => {
    // These are just log messages, not errors
    const message = data.toString().trim();
    if (message.includes('ERROR')) {
        console.error(`Session ${session.id}: VAD Error: ${message}`);
    } else {
        console.log(`Session ${session.id}: VAD Info: ${message}`);
    }
});

// Clean up buffer when process ends
session.vadProcess.on('exit', (code) => {
    console.log(`Session ${session.id}: VAD process exited with code ${code}`);
    session.vadOutputBuffer = '';
});